
\documentclass[article,type=bsc,colorback,accentcolor=tud9c]{tudthesis}
%\usepackage{ngerman}
\usepackage{hyperref}

\newcommand{\getmydate}{%
  \ifcase\month%
    \or Januar\or Februar\or M\"arz%
    \or April\or Mai\or Juni\or Juli%
    \or August\or September\or Oktober%
    \or November\or Dezember%
  \fi\ \number\year%
}

\begin{document}
  \thesistitle{Analysis of Methods for Background Execution in Modern Web Applications}%
    {Analyse von Verfahren für Hintergrundausführung in modernen Webanwendungen}
  \author{Yannick Reifschneider}
  \referee{Nikolay Matyunin}{Prof. Dr. Stefan Katzenbeisser}
  \department{Fachbereich Informatik}
  \group{Security Engineering}
  \dateofexam{\today}{\today}
  \tuprints{12345}{1234}
  \makethesistitle
  \affidavit{Yannick Reifschneider}

  \tableofcontents

  \newpage
  \section{Abstract}

  The application development industry shifts towards not developing native applications but instead use the browser as a universally available user interface platform. Web applications are indeed now capable of almost any task which would require a native application in the recent past. Popular word processing or spreadsheet applications for example are implemented with web technologies. A web site also has a completely different attack surface for a malicious actor then native applications. Browser engines do their best to protect their users of malicous web sites and also conserve energy.
  
  In this paper we analyse major browsers regarding their behaviour of JavaScript code exection, when the execution page is in the background and not visible to the user. We show that the energy conserving methods of desktop browsers can easily be circumvented to do arbitrary calculations for unlimited time while the web site is not user visible. With these findings we trace popular websites to see if they use similar methods to execute uninterrupted in the background.

  \newpage
  \section{Introduction}

  Web browsers are a fundamental application on many computing devices. They also have to be trusted by the user of the device, because they run application code of any visited website.

  Because browsers are so heavily used on many devices, they are encouraged to conserve battery and only use computing time, when they are really neccessary for the visited web page.

  Eventually all tabs in the background should be halted completely and only woken up, when the page is moved to the foreground again. Due to the very different kind of applications which can be built using web technologies, not all tabs can be halted completely without breaking the application.

  Many popular web sites earn money by showing ads on their page. These ads can in many cases also include JavaScript code, which then is executed on every visitor of this page.

  There are also implementations of crypto currency miners implemented in JavaScript. These mining scripts are programmed to earn money for the website owner at the cost of the CPU and energy usage of the website visitors.
  
  \subsection{Motivation}

  \begin{itemize}
  \item Possible side channel attack (i.e. via sensor readings)
  \item A XSS vulnerability in a popular website could use the visitors as a botnet for a DDOS attack
    
  \end{itemize}

  \subsection{Related works}

  
  \newpage
  \section{Background information}

  
  \subsection{The JavaScript execution model}

  The JavaScript language has no functions to perform I/O operations on it's own. It needs a runtime to perform the I/O task. All calls to the runtime are non-blocking.

  JavaScripts concurrency model is based on events and callbacks.

  When a JavaScript task is running, it is guaranteed to not be interrupted until it is completed. This insures, that a variable cannot change from outside. This is in contrast to many other programming languages like Java or C, where another thread can mutate variables at any time. To guarantee this behaviour, the web browser has to block and wait until the task finishes. Once the task is finished, the runtime can change and perform other work. Due to this properties JavaScript tasks should be as small as possible to ensure responsiveness of the browser. If a JavaScript task never completes (i.e. it is executing an inifite loop) most browser show a warning to the user that a script is slowing down the website. The user then has the option to kill the task or wait longer.

  

  
  
  Why a simple infinite loop is not feasable: Web page becomes unresponsive. If you don't yield back to the event loop, you can no longer react to changes in the environment, for example to detect, if the browser is now in the foreground again. This is at least true in the main loop, have to check for service worker or web worker context.
  
  \subsection{Web workers}

  Web workers are a mechanism to perform long running uninterruptable calculations. Due to the runtime guarantees which were described in the last section, Web workers have a completely seperate execution context. They don't share variables or resources with the invoking context.

  Web worker and main thread context can communicate by passing messages to each other, which are handled by their respective event loops. In contrast to the main thread, which can manipulate the DOM of the browser, the Web worker has limited functionality. But this limitation allows the web worker to run uninterrupted for long times. It does share resources with the browser renderer, and therefore does not block repaints or other browser events.

  

  \newpage
  \section{Analysis of different background execution methods}

  \subsection{Methods}

  
  \subsubsection{Timers}

  Standard method for scheduling a recurring function in JavaScript. The setInterval function allows to specify a function and an interval in milliseconds after which a function is repeatedly called until the interval is cancelled.
  
  \subsubsection{Web workers}
  
  Using the worker-timers\footnote{\url{https://github.com/chrisguttandin/worker-timers}} library to run a scheduler on a web worker, which calls a callback on the main loop. This circumenvents the setInterval throttling, when a browser tab is in the background.

  \subsubsection{Timers with open WebSocket connection}

  In some browsers window timers in background tabs are not throttled, when either audible music is playing or a websocket connection is open. Playing a sound file or opening a websocket connection work equaliy in preventing the throttling, but they differ hugely in how visible both are the user of the web page. While playing audio is audible and also marks your tab with a speaker icon, so the user can quickly find out, which tab is producing the sounds, opening a websocket connection is invisible to the user. Also many browser prevent automatic playback of audio and videos, because it is considered bad behaviour of the website to autoplay audible sounds.

  
  
  \subsubsection{Service workers}

  Service workers have advantages. They run independent of the browser tab. They stay can stay aliver after the browser tab, which installed the service worker is closed.

  \begin{itemize}   
  \item Multiple methods for background execution:

  \item Simple set interval after activation

  \item In response to network request (corresponding website has to be open to trigger a network call)

  \item Website push notifications (has to be allowed by user)

  \item Web Background Synchronization API\footnote{\url{https://wicg.github.io/BackgroundSync/spec/}}
  \end{itemize}

  
  \newpage

  \subsection{Browser behaviour}


  Firefox budget-based throttling
  \url{https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API#Policies_in_place_to_aid_background_page_performance}

  Chrome budget-based throttling
  \url{https://developers.google.com/web/updates/2017/03/background_tabs#budget-based_background_timer_throttling}

  Safari throttling



  Chrome Mobile

  Mobile Firefox

  Android Browser

  Mobile Safari

  Samsung Browser

  
  
  \subsection{Desktop web browsers}

  \subsubsection{Google Chrome}

  Chrome on macOS does not allow sensor readings while in background.

  AmbientLightSensor has to be enabled via flags.
  
  \subsubsection{Mozilla Firefox}

  Firefox does not support the Sensors API, but implements an older specification of the ambient light sensor API. This older API does not allow to specify a frequency in which the event handler is called. Also, this API is no longer enabled by default since Firefox 60 due to privacy concerns. Also Firefox does not call the event handlers, when the tab is in the background

  \subsubsection{Apple Safari}

  \subsection{Mobile web browsers}

  On iOS we only analyse Mobile Safari, because Apple does not allow other browser engines in the Apple AppStore. Every other browser app has to use the system-provided webview to be in accordance with § 2.5.6 from Apple Review Guidelines\footnote{\url{https://developer.apple.com/app-store/review/guidelines/\#software-requirements}}.

  On Android, we can differentiate between different browser engines.

  \subsubsection{iOS Mobile Safari}

  \subsubsection{Chrome for Android}

  \subsubsection{Firefox for Android}

  \newpage
  \section{Tracing of background execution on popular websites}

  Using the Alexa Top 100 Website list.
  
  \subsection{Method for measuring background execution}

  Maybe with puppeteer\footnote{\url{https://pptr.dev/}}, web developer tools or with OpenWPM\footnote{\url{https://github.com/mozilla/OpenWPM}} or with simple hooking the JavaScript functions



  
  \newpage
  \section{Evaluation of tracing results}

  
  \newpage
  \section{Conclusion}

  

  

   

\end{document}
