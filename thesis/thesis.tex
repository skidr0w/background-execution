
\documentclass[article,type=bsc,colorback,accentcolor=tud9c]{tudthesis}
%\usepackage{ngerman}
\usepackage{hyperref}
\usepackage{biblatex}
\usepackage{tikz}
\addbibresource{thesis.bib}

\newcommand{\getmydate}{%
  \ifcase\month%
    \or Januar\or Februar\or M\"arz%
    \or April\or Mai\or Juni\or Juli%
    \or August\or September\or Oktober%
    \or November\or Dezember%
  \fi\ \number\year%
}

\begin{document}
  \thesistitle{Analysis of Methods for Background Execution in Modern Web Applications}%
    {Analyse von Verfahren für Hintergrundausführung in modernen Webanwendungen}
  \author{Yannick Reifschneider}
  \referee{Nikolay Matyunin}{Prof. Dr. Stefan Katzenbeisser}
  \department{Fachbereich Informatik}
  \group{Security Engineering}
  \dateofexam{\today}{\today}
  \tuprints{12345}{1234}
  \makethesistitle
  \affidavit{Yannick Reifschneider}

  \tableofcontents

  \newpage
  \section{Abstract}

  In this thesis we analyse modern browsers regarding their behaviour of JavaScript code exection in background tabs. We show that the energy conserving methods of desktop browsers can easily be circumvented to do arbitrary calculations for unlimited time while the web site is not user visible. With these findings we trace popular websites to see if they use similar methods to execute uninterrupted in the background.

  \newpage
  \section{Introduction}

  Web technology received rapid advances in the last years. Many websites not only deliver static information in form of text and images, but are complete highly dynamic applications which compete with traditional software products. For many of the standard business applications like an E-mail client, a word processor or even a bitmap graphic manipulation software there are alterantives\cite{gmail}\cite{office365-online}\cite{photopea} which are developed using web technologies and used via a modern web browser. Some reasons for the rise of these web applications are, that browsers are getting more capable every year and the JavaScript performance is increasing drastically so that these applications are possible in the first place. Developing a web application instead of traditional software has also many benefits for the developer of said software. Web apps don't need installation, just a modern web browser, which comes preinstalled with any common operating system and mobile device. Visiting a web site to try out a piece of software is a much smaller hurdle to overcome then downloading, installing and running a piece of software. These reasons make the web a popular platform for developing new applications.

  At the same time, the revenue model for many websites is advertising. Websites include third party JavaScript from ad networks, which display ads and track impressions. The included code can be controlled by the advertiser. For a malicous entity, it is therefore possible to include JavaScript on reputable websites just by paying for the ad impression. This method of distribution for malicous script is known as malvertising\cite{wiki:malvertising}.

  The web browser is a fundamental application on most personal computing devices and is trusted by it's users. Because many modern applications are implemented as web apps, web browser usage is ubiquitous in the usage of computing devices. As such, many users leave the web browser open during the whole time they use their device, often times with many website tabs open. The browser vendors are encouraged to conserve as much energy as possible to enable users on battery powered devices, such as mobile phones or notebooks which are not tethered to a power outlet, a longer usage time. On the other side, the browser should not break web applications which require regular CPU time to function correctly. Web apps, which need regular CPU time are sites, which notify the user about new content such as a news site or a social network, a web application which plays audio or video, or a web video conference application. All modern browsers limit the amount of CPU time a tab in the background can use and how often web sites can schedule new work. For maximum energy efficiency, all tabs in the background should eventually be halted completely and only woken up, when the page is moved to the foreground again.

  In this thesis we find out, if the throttling mechanisms employed by browser vendors can be circumvented, so that web sites which are not visible to the browser can gain code execution for arbitrary time. We compare the different throttling mechanisms between desktop and mobile browsers and we trace popular websites to see if the found cirumvention tactics are actively used in the wild.
  
  \subsection{Motivation}

  
  
  Most browser usage is on mobile and notebooks where battery life is crucial.\autocite{webkit-web-content-power-usage} At the same time, some sites may be motivated to use cryptominers on visitors computers as an alternative to ad networks.
  
  \begin{itemize}
  \item Possible side channel attack (i.e. via sensor readings)
  \item A XSS vulnerability in a popular website could use the visitors as a botnet for a DDOS attack
  \end{itemize}

  \subsection{Related works}

  \begin{itemize}
  \item WebTAP does mass analysis of popular websites with regards to tracking.\autocite{webtap}

  \item Truth in Web Minining analyses the if Cryptocurrency miners are a viable alternative to traditional ad serving as a revenue possibility for web sites.\autocite{papadopoulos2018truth} They come to the conclusion, that cryptocurrency mining is more profitable when the user stays longer then xxx minutes on the website.
  

  \end{itemize}

  
  \newpage
  \section{Background}

  JavaScript is the only programming language supported by all modern web browsers to enhance web sites or web applocications. If you compare JavaScript to other more traditional programming languages like C, C++ or Java you see some major differences between them.

  \begin{itemize}
  \item JavaScript has no functions for I/O like writing to a file or opening a socket. It depends on a runtime environment like a browser to provide I/O functionality.
  \item JavaScript has no concept of parallelism like operating system threads or processes.
  \item JavaScript is an event driven language and has a built in event loop.
  \end{itemize}

  All of these differences stem from the fact, that JavaScript was designed as an addition to HTML for enhancing web applications and the interface to the browser internal workings, such as the DOM. Many of these design decisions are choosen, because JavaScript is run in the browser and therefore can be run on any website you visit. This poses many security implications, because you may not want to give a website you visit the power to execute arbitrary programms on your computer.

  Also explain why webassembly does nothing special in regards to background execution. That is, because it allows seamleas interop between webasm and Javascript functions. Therefore it has to run with the same runtime guarantees as JavaScript. WebASM Threads are based on Webworkers with a shared memory pool.
  WebASM therefore behaves exactly like javascript functions and have to yield to the event loop to not block the browser.

  
  \subsection{The JavaScript execution model}
  
  
  The JavaScript runtime uses an event loop to schedule tasks for execution\autocite{mdn-event-loop}. The browser or other JavaScript code can put tasks on the task queue. During a single run of the event loop, the runtime removes the first item of the task queue and executes it. When the event queue is empty, the run loop waits until an event is placed into the queue.

  When a JavaScript task is running, it is guaranteed to not be interrupted until it is completed. This insures, that a variable cannot change from outside. This is in contrast to many other programming languages like Java or C, where another thread can mutate variables at any time. To guarantee this behaviour, the JavaScript runtime in the web browser has to block and wait until the task finishes, because the JavaScript task has access to the browser internal state and DOM. Once the task is finished, the runtime can perform other work, such as layout calculations, which mutates its internal state. Due to these properties JavaScript tasks should be as small as possible to ensure responsiveness of the browser. If a JavaScript task takes a long time to complete (i.e. it is executing an infinite loop) most browser show a warning to the user that a script is slowing down the website. The user then has the option to kill the task or wait for the task to finish.
  
  
  \subsection{Web workers}

  Web workers are a mechanism to perform long running uninterruptable calculations. Due to the runtime guarantees which were described in the last section, Web workers have a completely seperate execution context. They don't share variables or resources with the invoking context.

  The web worker and main thread context can communicate by passing messages to each other, which are handled by their respective event loops. In contrast to the main thread, which can manipulate the DOM of the browser, the Web worker has limited functionality. This limitation allows the web worker to run uninterrupted for longer times, because it does not does not block browser events.


  \subsection{Trace event file format}

  Explain which information the trace event file includes and how they are used in the Chrome Devtools Frontend to display performance metrics.
  
  \newpage
  \section{Analysis of different background execution methods}

  \subsection{Methods}

  
  \subsubsection{Timers}

  Standard method for scheduling a recurring function in JavaScript. The setInterval function allows to specify a function and an interval in milliseconds after which a function is repeatedly called until the interval is cancelled.

  \begin{figure}
	\begin{center}
		\input{analysis-results/firefox-timer.txt.pgf}
	\end{center}
	\caption{Firefox CPU usage in background using timer method}
  \end{figure}
  
  \subsubsection{Web workers}
  
  Using the worker-timers\footnote{\url{https://github.com/chrisguttandin/worker-timers}} library to run a scheduler on a web worker, which calls a callback on the main loop. This circumenvents the setInterval throttling, when a browser tab is in the background.

  \subsubsection{Timers with open WebSocket connection}

  In some browsers window timers in background tabs are not throttled, when either audible music is playing or a websocket connection is open. Playing a sound file or opening a websocket connection work equaliy in preventing the throttling, but they differ hugely in how visible both are the user of the web page. While playing audio is audible and also marks your tab with a speaker icon, so the user can quickly find out, which tab is producing the sounds, opening a websocket connection is invisible to the user. Also many browser prevent automatic playback of audio and videos, because it is considered bad behaviour of the website to autoplay audible sounds.

  
  
  \subsubsection{Service workers}

  Service workers have advantages. They run independent of the browser tab. They stay can stay aliver after the browser tab, which installed the service worker is closed.

  \begin{itemize}   
  \item Multiple methods for background execution:

  \item Simple set interval after activation

  \item In response to network request (corresponding website has to be open to trigger a network call)

  \item Website push notifications (has to be allowed by user)

  \item Web Background Synchronization API\footnote{\url{https://wicg.github.io/BackgroundSync/spec/}}
  \end{itemize}

  
  \newpage

  \subsection{Browser behaviour}


  Firefox budget-based throttling
  \autocite{mdn-page-visibility}

  Chrome budget-based throttling
  \autocite{chrome-background-tabs}

  Safari behaviour

 
  
  \subsection{Desktop web browsers}

  Chrome on macOS does not allow sensor readings while in background.

  AmbientLightSensor has to be enabled via flags.
  

  Firefox does not support the Sensors API, but implements an older specification of the ambient light sensor API. This older API does not allow to specify a frequency in which the event handler is called. Also, this API is no longer enabled by default since Firefox 60 due to privacy concerns. Also Firefox does not call the event handlers, when the tab is in the background


  \subsection{Mobile web browsers}

  On iOS we only analyse Mobile Safari, because Apple does not allow other browser engines in the Apple AppStore. Every other browser app has to use the system-provided webview to be in accordance with § 2.5.6 from Apple Review Guidelines\footnote{\url{https://developer.apple.com/app-store/review/guidelines/\#software-requirements}}.

  On Android, we can differentiate between different browser engines.


  \newpage
  \section{Tracing of background execution on popular websites}

  In the first part of this thesis, we identified different methods to circumvent the default browser throttling mechanisms. With these findings in mind we can now trace popular websites\footnote{We used the first one thousand web sites of the Alexa Top 1m Website list} to analyse if these circumenvtion methods are used in the wild. Using the Alexa Top 1 million website list, we measure the average CPU usage of the websites. When we aggregate these tracing result, we can determine, if the browser throttling mechanisms are suiteable to limit CPU usage or if websites use these methods to actively or inadvertently bypass the background throttling mechanisms.
  
  \subsection{Automated measuring of background execution}

  To automate the tracing of popular websites we used the Puppeteer\cite{pptr} library to control and automate Google Chrome. We choose Puppeteer because it allows us to access the Chrome internals like Web Profiler and also inject custom scripts into the loaded page to detect if circumvention methods which are described in part one of this thesis are being used. Puppeteer only allows to control Google Chrome, but with Google Chrome having the greatest market share among common Web browsers this is not a limiting factor.

  The general idea for the tracing is, that we open a new Chrome instance and start the web profiling. Then we open the website to trace and wait for the initial load to complete. After that we move this website to the background by opening a new tab, so that the browser throttling mechanisms are activated. We profile the page for a 15 minutes time period. After the 15 minutes are completed, we close the browser instance and save the website trace for analysis.

  The website trace allows us to understand if the website is running JavaScript code while it is in the background and which methods it used to initiate the execution. On a invidual site level the website trace profile allows us to see, which JavaScript functions were run and how long they took to complete.

  The website trace profile allows us to dig deep into what a single website is executing while it is in the background. But to get a better picture of how popular websites in general behave in the background we have find a way to aggregate the analysis of the traces.

  We propose to use the average CPU usage during the profiling to use as a score for a single website. The average CPU score can be calculated from the trace file by calculating summed duration, in which the website executed JavaScript code in the main thread and in spawned worker threads and dividing the sum by the time the trace was running. Wall clock time is a suitable replacement for CPU time in a scenario where the machine on which the measurements are taken is not under any other load from other processes. A website which uses no JavaScript at all should therefore receive a score of 0, whereas a website which does run uninterupted calculations on the main thread should receive a score of 1. If a website uses multiple worker threads and the machine on which the measurements are taken has more then one physical CPU core, then the website could receive a score which is greater then 1, because all workers could be active at the same time.

  The background throttling mechanism put in place by Google Chrome does limit the timers of websites based on a CPU time budget. This budget is currently set so that websites on average only use 1\% of CPU usage. That would equal a score of 0.01 in our proposed metric. This limit gives a good estimation, if websites try to overcome the background throttling mechanism of Chrome. Websites which score greater then 0.01 presumably use one or more methods to prevent the throttling.

  


  
  \newpage
  \section{Evaluation of tracing results}
  
  \newpage
  \section{Conclusion}

  
  \newpage
  \printbibliography[heading=bibnumbered]

   

\end{document}
